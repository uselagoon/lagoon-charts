apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires container images to begin with a repo string from a specified list.
  name: k8sallowedrepos
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRepos
      validation:
        openAPIV3Schema:
          properties:
            repos:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8sallowedrepos

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        satisfied := [good | repo = input.parameters.repos[_] ; good = startswith(container.image, repo)]
        not any(satisfied)
        msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        satisfied := [good | repo = input.parameters.repos[_] ; good = startswith(container.image, repo)]
        not any(satisfied)
        msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Disallows all Services with type NodePort.
  name: k8sblocknodeport
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sBlockNodePort
  targets:
  - rego: |
      package k8sblocknodeport

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.object.spec.type == "NodePort"
        msg := "User is not allowed to create service of type NodePort"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires containers to have memory and CPU limits set and within a specified maximum amount.
  name: k8scontainerlimits
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sContainerLimits
      validation:
        openAPIV3Schema:
          properties:
            cpu:
              type: string
            memory:
              type: string
  targets:
  - rego: |
      package k8scontainerlimits

      missing(obj, field) = true {
        not obj[field]
      }

      missing(obj, field) = true {
        obj[field] == ""
      }

      canonify_cpu(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        endswith(orig, "m")
        new := to_number(replace(orig, "m", ""))
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        not endswith(orig, "m")
        re_match("^[0-9]+$", orig)
        new := to_number(orig) * 1000
      }

      # 10 ** 21
      mem_multiple("E") = 1000000000000000000000 { true }

      # 10 ** 18
      mem_multiple("P") = 1000000000000000000 { true }

      # 10 ** 15
      mem_multiple("T") = 1000000000000000 { true }

      # 10 ** 12
      mem_multiple("G") = 1000000000000 { true }

      # 10 ** 9
      mem_multiple("M") = 1000000000 { true }

      # 10 ** 6
      mem_multiple("k") = 1000000 { true }

      # 10 ** 3
      mem_multiple("") = 1000 { true }

      # Kubernetes accepts millibyte precision when it probably shouldn't.
      # https://github.com/kubernetes/kubernetes/issues/28741
      # 10 ** 0
      mem_multiple("m") = 1 { true }

      # 1000 * 2 ** 10
      mem_multiple("Ki") = 1024000 { true }

      # 1000 * 2 ** 20
      mem_multiple("Mi") = 1048576000 { true }

      # 1000 * 2 ** 30
      mem_multiple("Gi") = 1073741824000 { true }

      # 1000 * 2 ** 40
      mem_multiple("Ti") = 1099511627776000 { true }

      # 1000 * 2 ** 50
      mem_multiple("Pi") = 1125899906842624000 { true }

      # 1000 * 2 ** 60
      mem_multiple("Ei") = 1152921504606846976000 { true }

      get_suffix(mem) = suffix {
        not is_string(mem)
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 0
        suffix := substring(mem, count(mem) - 1, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        suffix := substring(mem, count(mem) - 2, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        not mem_multiple(substring(mem, count(mem) - 2, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 0
        suffix := ""
      }

      canonify_mem(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_mem(orig) = new {
        not is_number(orig)
        suffix := get_suffix(orig)
        raw := replace(orig, suffix, "")
        re_match("^[0-9]+$", raw)
        new := to_number(raw) * mem_multiple(suffix)
      }

      violation[{"msg": msg}] {
        general_violation[{"msg": msg, "field": "containers"}]
      }

      violation[{"msg": msg}] {
        general_violation[{"msg": msg, "field": "initContainers"}]
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.limits.cpu
        not canonify_cpu(cpu_orig)
        msg := sprintf("container <%v> cpu limit <%v> could not be parsed", [container.name, cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.limits.memory
        not canonify_mem(mem_orig)
        msg := sprintf("container <%v> memory limit <%v> could not be parsed", [container.name, mem_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources.limits
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "cpu")
        msg := sprintf("container <%v> has no cpu limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "memory")
        msg := sprintf("container <%v> has no memory limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.limits.cpu
        cpu := canonify_cpu(cpu_orig)
        max_cpu_orig := input.parameters.cpu
        max_cpu := canonify_cpu(max_cpu_orig)
        cpu > max_cpu
        msg := sprintf("container <%v> cpu limit <%v> is higher than the maximum allowed of <%v>", [container.name, cpu_orig, max_cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.limits.memory
        mem := canonify_mem(mem_orig)
        max_mem_orig := input.parameters.memory
        max_mem := canonify_mem(max_mem_orig)
        mem > max_mem
        msg := sprintf("container <%v> memory limit <%v> is higher than the maximum allowed of <%v>", [container.name, mem_orig, max_mem_orig])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Ingress resources to be HTTPS only; TLS configuration should be set and `kubernetes.io/ingress.allow-http` annotation equals false.
  name: k8shttpsonly
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sHttpsOnly
  targets:
  - rego: |
      package k8shttpsonly

      violation[{"msg": msg}] {
        input.review.object.kind == "Ingress"
        re_match("^(extensions|networking.k8s.io)/", input.review.object.apiVersion)
        ingress := input.review.object
        not https_complete(ingress)
        msg := sprintf("Ingress should be https. tls configuration and allow-http=false annotation are required for %v", [ingress.metadata.name])
      }

      https_complete(ingress) = true {
        ingress.spec["tls"]
        count(ingress.spec.tls) > 0
        ingress.metadata.annotations["kubernetes.io/ingress.allow-http"] == "false"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires container images to contain a digest.
  name: k8simagedigests
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sImageDigests
  targets:
  - rego: |
      package k8simagedigests

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        satisfied := [re_match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)]
        not all(satisfied)
        msg := sprintf("container <%v> uses an image without a digest <%v>", [container.name, container.image])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        satisfied := [re_match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)]
        not all(satisfied)
        msg := sprintf("initContainer <%v> uses an image without a digest <%v>", [container.name, container.image])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the user and group IDs of the container.
  name: k8spspallowedusers
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowedUsers
      validation:
        openAPIV3Schema:
          properties:
            fsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsUser:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            supplementalGroups:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
  targets:
  - rego: |
      package k8spspallowedusers

      violation[{"msg": msg}] {
        fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
        field := fields[_]
        container := input_containers[_]
        msg := get_type_violation(field, container)
      }

      get_type_violation(field, container) = msg {
        field == "runAsUser"
        params := input.parameters[field]
        msg := get_user_violation(params, container)
      }

      get_type_violation(field, container) = msg {
        field != "runAsUser"
        params := input.parameters[field]
        msg := get_violation(field, params, container)
      }

      # RunAsUser (separate due to "MustRunAsNonRoot")
      get_user_violation(params, container) = msg {
        rule := params.rule
        provided_user := get_field_value("runAsUser", container, input.review)
        not accept_users(rule, provided_user)
        msg := sprintf("Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [container.name, provided_user, params])
      }

      get_user_violation(params, container) = msg {
        not get_field_value("runAsUser", container, input.review)
        params.rule != "RunAsAny"
        msg := sprintf("Container %v is attempting to run without a required securityContext/runAsUser. Allowed runAsUser: %v", [container.name, params])
      }

      accept_users("RunAsAny", provided_user) {true}

      accept_users("MustRunAsNonRoot", provided_user) = res {res := provided_user != 0}

      accept_users("MustRunAs", provided_user) = res  {
        ranges := input.parameters.runAsUser.ranges
        res := is_in_range(provided_user, ranges)
      }

      # Group Options
      get_violation(field, params, container) = msg {
        rule := params.rule
        provided_value := get_field_value(field, container, input.review)
        not is_array(provided_value)
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [container.name, provided_value, field, params])
      }
      # SupplementalGroups is array value
      get_violation(field, params, container) = msg {
        rule := params.rule
        array_value := get_field_value(field, container, input.review)
        is_array(array_value)
        provided_value := array_value[_]
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [container.name, array_value, field, params])
      }

      get_violation(field, params, container) = msg {
        not get_field_value(field, container, input.review)
        params.rule == "MustRunAs"
        msg := sprintf("Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [container.name, field, field, params])
      }

      accept_value("RunAsAny", provided_value, ranges) {true}

      accept_value("MayRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}

      accept_value("MustRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}


      # If container level is provided, that takes precedence
      get_field_value(field, container, review) = out {
        container_value := get_seccontext_field(field, container)
        out := container_value
      }

      # If no container level exists, use pod level
      get_field_value(field, container, review) = out {
        not get_seccontext_field(field, container)
        review.kind.kind == "Pod"
        pod_value := get_seccontext_field(field, review.object.spec)
        out := pod_value
      }

      # Helper Functions
      is_in_range(val, ranges) = res {
        matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
        res := count(matching) > 0
      }

      get_seccontext_field(field, obj) = out {
        out = obj.securityContext[field]
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls restricting escalation to root privileges.
  name: k8spspallowprivilegeescalationcontainer
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowPrivilegeEscalationContainer
  targets:
  - rego: |
      package k8spspallowprivilegeescalationcontainer

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_allow_privilege_escalation(c)
          msg := sprintf("Privilege escalation container is not allowed: %v", [c.name])
      }

      input_allow_privilege_escalation(c) {
          not has_field(c, "securityContext")
      }
      input_allow_privilege_escalation(c) {
          not c.securityContext.allowPrivilegeEscalation == false
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the AppArmor profile used by containers.
  name: k8spspapparmor
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAppArmor
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspapparmor

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          container := input_containers[_]
          not input_apparmor_allowed(container, metadata)
          msg := sprintf("AppArmor profile is not allowed, pod: %v, container: %v. Allowed profiles: %v", [input.review.object.metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_apparmor_allowed(container, metadata) {
          metadata.annotations[key] == input.parameters.allowedProfiles[_]
          key == sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls Linux capabilities.
  name: k8spspcapabilities
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPCapabilities
      validation:
        openAPIV3Schema:
          properties:
            allowedCapabilities:
              items:
                type: string
              type: array
            requiredDropCapabilities:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package capabilities

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        missing_drop_capabilities(container)
        msg := sprintf("container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }


      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("init container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        missing_drop_capabilities(container)
        msg := sprintf("init container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }


      has_disallowed_capabilities(container) {
        allowed := {c | c := input.parameters.allowedCapabilities[_]}
        not allowed["*"]
        capabilities := {c | c := container.securityContext.capabilities.add[_]}
        count(capabilities - allowed) > 0
      }

      missing_drop_capabilities(container) {
        must_drop := {c | c := input.parameters.requiredDropCapabilities[_]}
        dropped := {c | c := container.securityContext.capabilities.drop[_]}
        count(must_drop - dropped) > 0
      }

      get_default(obj, param, _default) = out {
        out = obj[param]
      }

      get_default(obj, param, _default) = out {
        not obj[param]
        not obj[param] == false
        out = _default
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the allowlist of Flexvolume drivers.
  name: k8spspflexvolumes
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFlexVolumes
      validation:
        openAPIV3Schema:
          properties:
            allowedFlexVolumes:
              items:
                properties:
                  driver:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspflexvolumes

      violation[{"msg": msg, "details": {}}] {
          volume := input_flexvolumes[_]
          not input_flexvolumes_allowed(volume)
          msg := sprintf("FlexVolume %v is not allowed, pod: %v. Allowed drivers: %v", [volume, input.review.object.metadata.name, input.parameters.allowedFlexVolumes])
      }

      input_flexvolumes_allowed(volume) {
          input.parameters.allowedFlexVolumes[_].driver == volume.flexVolume.driver
      }

      input_flexvolumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "flexVolume")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the `sysctl` profile used by containers.
  name: k8spspforbiddensysctls
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPForbiddenSysctls
      validation:
        openAPIV3Schema:
          properties:
            forbiddenSysctls:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspforbiddensysctls

      violation[{"msg": msg, "details": {}}] {
          sysctl := input.review.object.spec.securityContext.sysctls[_].name
          forbidden_sysctl(sysctl)
          msg := sprintf("The sysctl %v is not allowed, pod: %v. Forbidden sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.forbiddenSysctls])
      }

      # * may be used to forbid all sysctls
      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == "*"
      }

      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == sysctl
      }

      forbidden_sysctl(sysctl) {
          startswith(sysctl, trim(input.parameters.forbiddenSysctls[_], "*"))
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls allocating an FSGroup that owns the Pod's volumes.
  name: k8spspfsgroup
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFSGroup
      validation:
        openAPIV3Schema:
          properties:
            ranges:
              items:
                properties:
                  max:
                    type: integer
                  min:
                    type: integer
                type: object
              type: array
            rule:
              type: string
  targets:
  - rego: |
      package k8spspfsgroup

      violation[{"msg": msg, "details": {}}] {
        spec := input.review.object.spec
        not input_fsGroup_allowed(spec)
        msg := sprintf("The provided pod spec fsGroup is not allowed, pod: %v. Allowed fsGroup: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_fsGroup_allowed(spec) {
        # RunAsAny - No range is required. Allows any fsGroup ID to be specified.
        input.parameters.rule == "RunAsAny"
      }
      input_fsGroup_allowed(spec) {
        # MustRunAs - Validates pod spec fsgroup against all ranges
        input.parameters.rule == "MustRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not has_field(spec, "securityContext")
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not spec.securityContext.fsGroup
      }
      input_fsGroup_allowed(spec) {
        # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
        input.parameters.rule == "MayRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      value_within_range(range, value) {
        range.min <= value
        range.max >= value
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
        object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of the host filesystem.
  name: k8spsphostfilesystem
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostFilesystem
      validation:
        openAPIV3Schema:
          properties:
            allowedHostPaths:
              items:
                properties:
                  pathPrefix:
                    type: string
                  readOnly:
                    type: boolean
                type: object
              type: array
  targets:
  - rego: |
      package k8spsphostfilesystem

      violation[{"msg": msg, "details": {}}] {
          volume := input_hostpath_volumes[_]
          allowedPaths := get_allowed_paths(input)
          input_hostpath_violation(allowedPaths, volume)
          msg := sprintf("HostPath volume %v is not allowed, pod: %v. Allowed path: %v", [volume, input.review.object.metadata.name, allowedPaths])
      }

      input_hostpath_violation(allowedPaths, volume) {
          # An empty list means all host paths are blocked
          allowedPaths == []
      }
      input_hostpath_violation(allowedPaths, volume) {
          not input_hostpath_allowed(allowedPaths, volume)
      }

      get_allowed_paths(arg) = out {
          not arg.parameters
          out = []
      }
      get_allowed_paths(arg) = out {
          not arg.parameters.allowedHostPaths
          out = []
      }
      get_allowed_paths(arg) = out {
          out = arg.parameters.allowedHostPaths
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          not allowedHostPath.readOnly == true
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          allowedHostPath.readOnly
          not writeable_input_volume_mounts(volume.name)
      }

      writeable_input_volume_mounts(volume_name) {
          container := input_containers[_]
          mount := container.volumeMounts[_]
          mount.name == volume_name
          not mount.readOnly
      }

      # This allows "/foo", "/foo/", "/foo/bar" etc., but
      # disallows "/fool", "/etc/foo" etc.
      path_matches(prefix, path) {
          a := split(trim(prefix, "/"), "/")
          b := split(trim(path, "/"), "/")
          prefix_matches(a, b)
      }
      prefix_matches(a, b) {
          count(a) <= count(b)
          not any_not_equal_upto(a, b, count(a))
      }

      any_not_equal_upto(a, b, n) {
          a[i] != b[i]
          i < n
      }

      input_hostpath_volumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "hostPath")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of host namespaces.
  name: k8spsphostnamespace
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNamespace
  targets:
  - rego: |
      package k8spsphostnamespace

      violation[{"msg": msg, "details": {}}] {
          input_share_hostnamespace(input.review.object)
          msg := sprintf("Sharing the host namespace is not allowed: %v", [input.review.object.metadata.name])
      }

      input_share_hostnamespace(o) {
          o.spec.hostPID
      }
      input_share_hostnamespace(o) {
          o.spec.hostIPC
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of host networking and ports.
  name: k8spsphostnetworkingports
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNetworkingPorts
      validation:
        openAPIV3Schema:
          properties:
            hostNetwork:
              type: boolean
            max:
              type: integer
            min:
              type: integer
  targets:
  - rego: |
      package k8spsphostnetworkingports

      violation[{"msg": msg, "details": {}}] {
        input_share_hostnetwork(input.review.object)
        msg := sprintf("The specified hostNetwork and hostPort are not allowed, pod: %v. Allowed values: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_share_hostnetwork(o) {
        not input.parameters.hostNetwork
        o.spec.hostNetwork
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort < input.parameters.min
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort > input.parameters.max
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls running of privileged containers.
  name: k8spspprivilegedcontainer
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPPrivilegedContainer
  targets:
  - rego: |
      package k8spspprivileged

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          c.securityContext.privileged
          msg := sprintf("Privileged container is not allowed: %v, securityContext: %v", [c.name, c.securityContext])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the allowed `procMount` types for the container.
  name: k8spspprocmount
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPProcMount
      validation:
        openAPIV3Schema:
          properties:
            procMount:
              type: string
  targets:
  - rego: |
      package k8spspprocmount

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          allowedProcMount := get_allowed_proc_mount(input)
          not input_proc_mount_type_allowed(allowedProcMount, c)
          msg := sprintf("ProcMount type is not allowed, container: %v. Allowed procMount types: %v", [c.name, allowedProcMount])
      }

      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "default"
          lower(c.securityContext.procMount) == "default"
      }
      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "unmasked"
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
          c.securityContext.procMount
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
          c.securityContext.procMount
      }

      get_allowed_proc_mount(arg) = out {
          not arg.parameters
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not arg.parameters.procMount
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not valid_proc_mount(arg.parameters.procMount)
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          out = lower(arg.parameters.procMount)
      }

      valid_proc_mount(str) {
          lower(str) == "default"
      }
      valid_proc_mount(str) {
          lower(str) == "unmasked"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires the use of a read only root file system.
  name: k8spspreadonlyrootfilesystem
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPReadOnlyRootFilesystem
  targets:
  - rego: |
      package k8spspreadonlyrootfilesystem

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_read_only_root_fs(c)
          msg := sprintf("only read-only root filesystem container is allowed: %v", [c.name])
      }

      input_read_only_root_fs(c) {
          not has_field(c, "securityContext")
      }
      input_read_only_root_fs(c) {
          not c.securityContext.readOnlyRootFilesystem == true
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the seccomp profile used by containers.
  name: k8spspseccomp
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSeccomp
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspseccomp

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          not input_wildcard_allowed(metadata)
          container := input_containers[_]
          not input_container_allowed(metadata, container)
          msg := sprintf("Seccomp profile is not allowed, pod: %v, container: %v, Allowed profiles: %v", [metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_wildcard_allowed(metadata) {
          input.parameters.allowedProfiles[_] == "*"
      }

      input_container_allowed(metadata, container) {
          not get_container_profile(metadata, container)
          metadata.annotations["seccomp.security.alpha.kubernetes.io/pod"] == input.parameters.allowedProfiles[_]
      }

      input_container_allowed(metadata, container) {
        profile := get_container_profile(metadata, container)
        profile == input.parameters.allowedProfiles[_]
      }

      get_container_profile(metadata, container) = profile {
        value := metadata.annotations[key]
          startswith(key, "container.seccomp.security.alpha.kubernetes.io/")
          [prefix, name] := split(key, "/")
          name == container.name
          profile = value
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the SELinux context of the container.
  name: k8spspselinuxv2
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSELinuxV2
      validation:
        openAPIV3Schema:
          properties:
            allowedSELinuxOptions:
              items:
                properties:
                  level:
                    type: string
                  role:
                    type: string
                  type:
                    type: string
                  user:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspselinux

      # Disallow top level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          has_field(input.review.object.spec.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(input.review.object.spec.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
      }
      # Disallow container level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          c := input_security_context[_]
          has_field(c.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v, container %v. Allowed options: %v", [input.review.object.metadata.name, c.name, input.parameters.allowedSELinuxOptions])
      }

      input_seLinuxOptions_allowed(options) {
          params := input.parameters.allowedSELinuxOptions[_]
          field_allowed("level", options, params)
          field_allowed("role", options, params)
          field_allowed("type", options, params)
          field_allowed("user", options, params)
      }

      field_allowed(field, options, params) {
          params[field] == options[field]
      }
      field_allowed(field, options, params) {
          not has_field(options, field)
      }

      input_security_context[c] {
          c := input.review.object.spec.containers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }
      input_security_context[c] {
          c := input.review.object.spec.initContainers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of volume types.
  name: k8spspvolumetypes
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sPSPVolumeTypes
      validation:
        openAPIV3Schema:
          properties:
            volumes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspvolumetypes

      violation[{"msg": msg, "details": {}}] {
          volume_fields := {x | input.review.object.spec.volumes[_][x]; x != "name"}
          field := volume_fields[_]
          not input_volume_type_allowed(field)
          msg := sprintf("The volume type %v is not allowed, pod: %v. Allowed volume types: %v", [field, input.review.object.metadata.name, input.parameters.volumes])
      }

      # * may be used to allow all volume types
      input_volume_type_allowed(field) {
          input.parameters.volumes[_] == "*"
      }

      input_volume_type_allowed(field) {
          field == input.parameters.volumes[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires all resources to contain a specified label with a value matching a provided regular expression.
  name: k8srequiredlabels
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          properties:
            labels:
              items:
                properties:
                  allowedRegex:
                    type: string
                  key:
                    type: string
                type: object
              type: array
            message:
              type: string
  targets:
  - rego: |
      package k8srequiredlabels

      get_message(parameters, _default) = msg {
        not parameters.message
        msg := _default
      }

      get_message(parameters, _default) = msg {
        msg := parameters.message
      }

      violation[{"msg": msg, "details": {"missing_labels": missing}}] {
        provided := {label | input.review.object.metadata.labels[label]}
        required := {label | label := input.parameters.labels[_].key}
        missing := required - provided
        count(missing) > 0
        def_msg := sprintf("you must provide labels: %v", [missing])
        msg := get_message(input.parameters, def_msg)
      }

      violation[{"msg": msg}] {
        value := input.review.object.metadata.labels[key]
        expected := input.parameters.labels[_]
        expected.key == key
        # do not match if allowedRegex is not defined, or is an empty string
        expected.allowedRegex != ""
        not re_match(expected.allowedRegex, value)
        def_msg := sprintf("Label <%v: %v> does not satisfy allowed regex: %v", [key, value, expected.allowedRegex])
        msg := get_message(input.parameters, def_msg)
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Pods to have readiness and/or liveness probes.
  name: k8srequiredprobes
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredProbes
      validation:
        openAPIV3Schema:
          properties:
            probeTypes:
              items:
                type: string
              type: array
            probes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8srequiredprobes

      probe_type_set = probe_types {
        probe_types := {type | type := input.parameters.probeTypes[_]}
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        probe := input.parameters.probes[_]
        probe_is_missing(container, probe)
        msg := get_violation_message(container, input.review, probe)
      }

      probe_is_missing(ctr, probe) = true {
        not ctr[probe]
      }

      probe_is_missing(ctr, probe) = true {
        probe_field_empty(ctr, probe)
      }

      probe_field_empty(ctr, probe) = true {
        probe_fields := {field | ctr[probe][field]}
        diff_fields := probe_type_set - probe_fields
        count(diff_fields) == count(probe_type_set)
      }

      get_violation_message(container, review, probe) = msg {
        msg := sprintf("Container <%v> in your <%v> <%v> has no <%v>", [container.name, review.kind.kind, review.object.metadata.name, probe])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires all Ingress hosts to be unique.
  name: k8suniqueingresshost
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueIngressHost
  targets:
  - rego: |
      package k8suniqueingresshost

      identical(obj, review) {
        obj.metadata.namespace == review.object.metadata.namespace
        obj.metadata.name == review.object.metadata.name
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Ingress"
        re_match("^(extensions|networking.k8s.io)$", input.review.kind.group)
        host := input.review.object.spec.rules[_].host
        other := data.inventory.namespace[ns][otherapiversion]["Ingress"][name]
        re_match("^(extensions|networking.k8s.io)/.+$", otherapiversion)
        other.spec.rules[_].host == host
        not identical(other, input.review)
        msg := sprintf("ingress host conflicts with an existing ingress <%v>", [host])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Services to have unique selectors within a namespace.
  name: k8suniqueserviceselector
  labels:
    {{- include "lagoon-gatekeeper.labels" . | nindent 4 }}
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueServiceSelector
  targets:
  - rego: |
      package k8suniqueserviceselector

      make_apiversion(kind) = apiVersion {
        g := kind.group
        v := kind.version
        g != ""
        apiVersion = sprintf("%v/%v", [g, v])
      }

      make_apiversion(kind) = apiVersion {
        kind.group == ""
        apiVersion = kind.version
      }

      identical(obj, review) {
        obj.metadata.namespace == review.namespace
        obj.metadata.name == review.name
        obj.kind == review.kind.kind
        obj.apiVersion == make_apiversion(review.kind)
      }

      flatten_selector(obj) = flattened {
        selectors := [s | s = concat(":", [key, val]); val = obj.spec.selector[key]]
        flattened := concat(",", sort(selectors))
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.kind.version == "v1"
        input.review.kind.group == ""
        input_selector := flatten_selector(input.review.object)
        other := data.inventory.namespace[namespace][_][_][name]
        not identical(other, input.review)
        other_selector := flatten_selector(other)
        input_selector == other_selector
        msg := sprintf("same selector as service <%v> in namespace <%v>", [name, namespace])
      }
    target: admission.k8s.gatekeeper.sh
